// Activity Service - 활동 타임라인 관리
import prisma from '../lib/prisma';
import { ActivityType } from '@prisma/client';

interface CreateActivityInput {
  entityType: string;
  entityId: string;
  type: ActivityType;
  subject: string;
  content?: string;
  metadata?: Record<string, any>;
  contactName?: string;
  contactInfo?: string;
  duration?: number;
  activityDate?: Date;
  nextAction?: string;
  nextDate?: Date;
  attachments?: any[];
  userId: string;
  isAutoGenerated?: boolean;
  automationRuleId?: string;
}

interface ActivityQuery {
  entityType?: string;
  entityId?: string;
  type?: ActivityType;
  userId?: string;
  startDate?: Date;
  endDate?: Date;
  page?: number;
  limit?: number;
}

export class ActivityService {
  // 활동 목록 조회
  async getActivities(query: ActivityQuery) {
    const {
      entityType,
      entityId,
      type,
      userId,
      startDate,
      endDate,
      page = 1,
      limit = 20
    } = query;

    const where: any = {};

    if (entityType) where.entityType = entityType;
    if (entityId) where.entityId = entityId;
    if (type) where.type = type;
    if (userId) where.userId = userId;
    
    if (startDate || endDate) {
      where.activityDate = {};
      if (startDate) where.activityDate.gte = startDate;
      if (endDate) where.activityDate.lte = endDate;
    }

    const [activities, total] = await Promise.all([
      prisma.activity.findMany({
        where,
        include: {
          user: { select: { id: true, name: true } }
        },
        orderBy: { activityDate: 'desc' },
        skip: (page - 1) * limit,
        take: limit
      }),
      prisma.activity.count({ where })
    ]);

    // 유형별 집계
    const byType = await prisma.activity.groupBy({
      by: ['type'],
      where,
      _count: true
    });

    const summary = {
      total,
      byType: byType.reduce((acc, item) => {
        acc[item.type] = item._count;
        return acc;
      }, {} as Record<string, number>)
    };

    return {
      activities,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      },
      summary
    };
  }

  // 활동 생성
  async createActivity(input: CreateActivityInput) {
    return prisma.activity.create({
      data: {
        entityType: input.entityType,
        entityId: input.entityId,
        type: input.type,
        subject: input.subject,
        content: input.content,
        metadata: input.metadata,
        contactName: input.contactName,
        contactInfo: input.contactInfo,
        duration: input.duration,
        activityDate: input.activityDate || new Date(),
        nextAction: input.nextAction,
        nextDate: input.nextDate,
        attachments: input.attachments,
        userId: input.userId,
        isAutoGenerated: input.isAutoGenerated || false,
        automationRuleId: input.automationRuleId
      },
      include: {
        user: { select: { id: true, name: true } }
      }
    });
  }

  // 활동 상세 조회
  async getActivityById(id: string) {
    return prisma.activity.findUnique({
      where: { id },
      include: {
        user: { select: { id: true, name: true } }
      }
    });
  }

  // 활동 수정
  async updateActivity(id: string, data: Partial<CreateActivityInput>) {
    return prisma.activity.update({
      where: { id },
      data: {
        subject: data.subject,
        content: data.content,
        metadata: data.metadata,
        contactName: data.contactName,
        contactInfo: data.contactInfo,
        duration: data.duration,
        activityDate: data.activityDate,
        nextAction: data.nextAction,
        nextDate: data.nextDate,
        attachments: data.attachments
      },
      include: {
        user: { select: { id: true, name: true } }
      }
    });
  }

  // 활동 삭제
  async deleteActivity(id: string) {
    return prisma.activity.delete({ where: { id } });
  }

  // 엔티티 타임라인 조회
  async getTimeline(entityType: string, entityId: string) {
    const activities = await prisma.activity.findMany({
      where: { entityType, entityId },
      include: {
        user: { select: { id: true, name: true } }
      },
      orderBy: { activityDate: 'desc' }
    });

    // 엔티티 요약 정보 조회
    let entity: any = null;
    switch (entityType.toUpperCase()) {
      case 'LEAD':
        entity = await prisma.lead.findUnique({
          where: { id: entityId },
          select: { id: true, companyName: true, contactName: true, status: true }
        });
        break;
      case 'CUSTOMER':
        entity = await prisma.customer.findUnique({
          where: { id: entityId },
          select: { id: true, name: true, company: true, grade: true }
        });
        break;
      case 'CONTRACT':
        entity = await prisma.contract.findUnique({
          where: { id: entityId },
          select: { id: true, contractNumber: true, title: true, status: true }
        });
        break;
      case 'STUDY':
        entity = await prisma.study.findUnique({
          where: { id: entityId },
          select: { id: true, studyNumber: true, testName: true, status: true }
        });
        break;
      case 'QUOTATION':
        entity = await prisma.quotation.findUnique({
          where: { id: entityId },
          select: { id: true, quotationNumber: true, customerName: true, status: true }
        });
        break;
    }

    return {
      timeline: activities.map(a => ({
        id: a.id,
        type: a.type,
        subject: a.subject,
        content: a.content,
        date: a.activityDate.toISOString(),
        user: a.user,
        isAutoGenerated: a.isAutoGenerated,
        metadata: a.metadata
      })),
      entity
    };
  }

  // 예정된 활동 조회
  async getUpcomingActivities(userId: string, days: number = 7) {
    const endDate = new Date();
    endDate.setDate(endDate.getDate() + days);

    return prisma.activity.findMany({
      where: {
        userId,
        nextDate: {
          gte: new Date(),
          lte: endDate
        }
      },
      include: {
        user: { select: { id: true, name: true } }
      },
      orderBy: { nextDate: 'asc' }
    });
  }

  // 자동 활동 생성 (상태 변경 시)
  async createStatusChangeActivity(
    entityType: string,
    entityId: string,
    userId: string,
    fromStatus: string,
    toStatus: string,
    metadata?: Record<string, any>
  ) {
    return this.createActivity({
      entityType,
      entityId,
      type: 'STATUS_CHANGE',
      subject: `상태 변경: ${fromStatus} → ${toStatus}`,
      metadata: { fromStatus, toStatus, ...metadata },
      userId,
      isAutoGenerated: true
    });
  }
}

export const activityService = new ActivityService();
